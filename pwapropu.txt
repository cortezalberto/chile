
Tú dijiste:
estoy realizando una aplicacion pwamenu en react 19 desde mobile y accedo a un qr que se indentifica la sucursal la mesa la hora el dia y su estado, dicho qr pueden ser elidos por varios comensales. La idea es que cada comensal de la mesa pueda ordenar con su novil lo que desea y que se comporta online el carrito con el consumo , a medida que se ordena se presiona un botos para ordenar y esto cargaa la cuenta final de la mesa, si s evuelve  aordenar otra cosa se considera una roimda y s eimpita al comensal que lo ordeno. una vez finalizado de comer se desea pedir la cuenta y que existan forma d epagar que uno pague el total d ela cuenta, que cada uno pague lo que cponsunmio o que cada unpo ponga dinero en forma indistinta hasta completar la cuenta, puede ser que un comensal pague con mercado loibre y otros en egectivos
ChatGPT Plus
Perfecto: lo que describís es un “carrito compartido por mesa” + “órdenes por rondas” + “liquidación flexible (split payments mixtos)”. Si lo diseñás bien desde el modelo de datos, después pagar “uno todo / cada uno lo suyo / aportes libres” sale natural.

Abajo te dejo una propuesta técnica y operativa (backend + realtime + modelo de pagos), pensada para PWA React 19 y backend Python.

1) Concepto clave: separar “Mesa” de “Sesión de Mesa”
Tu QR no debería identificar “la mesa para siempre”, sino una sesión activa (lo que dura ese grupo comiendo).

QR (lo mínimo recomendado)
restaurant_slug / branch_slug / table_slug

session_token (o un session_id firmado)

opcional: timestamp (para auditoría), pero no lo uses como “identidad”

Idea: cuando se “abre mesa”, se crea table_session y se imprime/actualiza el QR con ese token (o lo mostrás en un display).

2) Modelo de datos recomendado (alto nivel)
Identidad y participación
Branch(id, slug, nombre)

Table(id, branch_id, slug, etiqueta)

TableSession(id, table_id, status: OPEN|CLOSED, opened_at, closed_at, session_token_hash)

Diner(id, session_id, display_name, joined_at, device_fingerprint_hash opcional)

Cada comensal entra con QR y se crea/recupera su diner_id dentro de esa sesión.

Carrito / órdenes / rondas
Round(id, session_id, number, opened_at, closed_at, status: OPEN|SENT|LOCKED)

Order(id, session_id, round_id, diner_id, status: DRAFT|SENT|CANCELLED, created_at)

OrderItem(id, order_id, menu_item_id, qty, unit_price, notes, status)

Una “ronda” es un agrupador lógico: “lo que se mandó a cocina en esta tanda”.
Y cada ítem queda imputable al comensal que lo pidió.

Cuenta (ledger)
Charge(id, session_id, order_item_id, diner_id, amount, created_at)
(esto es el “cargo contable”)

PaymentIntent(id, session_id, provider: MP|CASH|OTHER, status, created_at)

Payment(id, session_id, payer_diner_id nullable, method: MP|CASH, amount, status, external_ref, created_at)

Allocation(id, payment_id, charge_id nullable, target: DINER|SESSION, amount)

La magia está en Allocation: te permite soportar:

“Pago solo lo mío” → allocás a cargos de ese diner

“Pago total” → allocás a toda la sesión

“Aportes libres” → allocás a lo que falte, sin importar de quién sea

3) Estados y reglas simples (sin volverte loco)
Estados de la sesión
OPEN: se puede ordenar y pagar

CHECK_REQUESTED: alguien pidió la cuenta (opcional)

PAYING: ya se están registrando pagos

CLOSED: saldo = 0 y se cerró

Reglas clave
Una orden “SENT” no se edita (solo se anula con compensación).

Los cargos (Charge) nacen al enviar a cocina (o al confirmar la orden).

La deuda de la mesa = suma(cargos) - suma(pagos confirmados).

No confíes en “hora/día en QR” como verdad: eso es servidor.

4) Realtime: carrito compartido “online” (sin pisarse)
Para que varios comensales vean el consumo en vivo, necesitás sincronización por sesión:

Opción A (recomendada): WebSocket por session_id
Canal: session:{session_id}

Eventos:

diner_joined

cart_updated (si manejás carrito común)

order_sent

charges_updated

payment_created|payment_confirmed

session_status_changed

Opción B: SSE (simple, unidireccional)
Más fácil que WS, pero menos interactivo

Importante: evitá un “carrito único editable por todos” si querés evitar conflictos.
En su lugar:

Cada comensal tiene su Order DRAFT

El “carrito global” se muestra como vista agregada (sumatoria de drafts + sent)

5) UX / flujo del comensal (PWA)
Escanea QR → POST /sessions/join
Respuesta: session_id, diner_id, permisos (guest)

Ve menú → arma su pedido local (draft)
PUT /orders/{order_id} o POST /orders/draft/items

“Enviar pedido” → POST /orders/{order_id}/send
Backend:

crea Charge por ítem

bloquea edición

emite evento realtime

“Pedir la cuenta” → POST /sessions/{id}/request-check
(solo cambia estado y notifica al mozo)

6) La parte difícil: pagos mixtos y “split” flexible
Tu requerimiento incluye 3 modos y además mezcla Mercado Pago + efectivo:

Modo 1 — “Uno paga todo”
Un payer hace un pago MP por el total restante

Allocation.target = SESSION por el monto

Listo

Modo 2 — “Cada uno paga lo que consumió”
Se calcula “deuda por diner” = suma(cargos diner) - suma(pagos ya asignados a ese diner)

Cada comensal paga su deuda (MP o efectivo)

Allocation se hace contra charges de ese diner

Modo 3 — “Aportes libres hasta completar”
Cada pago entra como “pool”

Se asigna automáticamente a los cargos pendientes en orden:

primero los más viejos (FIFO), o

primero los del payer (si querés “justicia percibida”), y luego el resto

Esto lo define tu algoritmo de asignación

Algoritmo simple de asignación (recomendado)
Cuando entra un pago confirmado:

obtener lista de charges pendientes (amount - allocated_amount > 0)

recorrer y asignar hasta agotar el pago

generar Allocation por cada tramo

Eso soporta que:

uno pague “parte” con MP,

otro complete en efectivo,

o aporten varios indistintamente.

7) Mercado Pago + efectivo (operación real)
Mercado Pago
Generás un PaymentIntent (por sesión o por diner)

Mostrás QR/link de pago al comensal (ideal: cada uno paga desde su celu)

Webhook de MP confirma → Payment.status=CONFIRMED

Asignás (Allocation) según el modo elegido

Efectivo
No hay webhook: lo registra el mozo/cajero

POST /payments/cash con amount

Se asigna igual que MP

Clave operativa: solo el mozo debería poder confirmar “cash recibido”.
El comensal puede “declarar” intención, pero no confirmarlo.

8) Roles y permisos mínimos (RBAC simple)
guest (comensal): ver menú, crear draft propio, enviar orden propia, ver cuenta agregada, iniciar pago MP

waiter: ver sesiones, ver pedidos, marcar cash, cerrar sesión

admin: todo

9) Endpoints mínimos que vas a necesitar (backend Python)
POST /sessions/join (con token del QR)

GET /sessions/{id}/state (resumen: cargos, pagos, saldo, por diner)

POST /orders/draft (crea draft para diner si no existe)

PUT /orders/{id}/items (agregar/quitar)

POST /orders/{id}/send

POST /sessions/{id}/request-check

POST /payments/mp/create-intent (por diner o por sesión)

POST /payments/mp/webhook (confirmación)

POST /payments/cash (solo mozo)

POST /payments/{id}/allocate (si querés manual)

POST /sessions/{id}/close (si saldo=0)

Realtime:

WS /ws?session_id=...&diner_id=... o SSE /sessions/{id}/events

10) Decisión importante: ¿cómo identificás a cada comensal?
No necesitás login. Pero sí una identidad estable durante la sesión:

al join guardás diner_id en localStorage (o IndexedDB)

si refresca, recupera su diner_id

si cambia de celu, será otro diner (ok)

Si querés mejorar:

“Unirse como Juan / Ana” (display_name)

opcional: “transferir ítems” si alguien se fue (función de mozo)

Si querés, en el próximo mensaje te dejo un esquema SQL real (PostgreSQL) para estas tablas + un ejemplo de payloads JSON para:

estado de mesa,

resumen por comensal,

y cómo se ve el “ledger” de cargos/pagos/asignaciones en pantalla.

Y si me confirmás que tu backend es FastAPI + Postgres, te lo bajo directo a modelos SQLAlchemy + endpoints.

Tú dijiste:
FastAPI + Postgres, te lo bajo directo a modelos SQLAlchemy + endpoints.
ChatGPT Plus
Listo. Abajo tenés una base funcional real (no pseudo) con:

Modelos SQLAlchemy 2.0 (async) para: Branch, Table, TableSession, Diner, Round, Order, OrderItem, Charge, Payment, Allocation

Endpoints FastAPI para:

POST /sessions/join (QR → sesión + comensal)

GET /sessions/{id}/state (deuda total + por comensal)

POST /orders/draft + PUT /orders/{id}/items (carrito por comensal)

POST /orders/{id}/send (crea cargos contables)

POST /payments/cash (registro efectivo)

POST /sessions/{id}/close (cierra si saldo=0)

Algoritmo real de allocation (pago “aportes libres” por FIFO a cargos pendientes)

Stack: fastapi, sqlalchemy>=2, asyncpg, pydantic>=2, uvicorn.

1) Modelos + DB (SQLAlchemy async)
# app/db.py
from __future__ import annotations
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

DATABASE_URL = "postgresql+asyncpg://user:pass@localhost:5432/pwamenu"

engine = create_async_engine(DATABASE_URL, echo=False, pool_pre_ping=True)
SessionLocal = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with SessionLocal() as session:
        yield session
# app/models.py
from __future__ import annotations

import enum
from datetime import datetime
from typing import Optional, List

from sqlalchemy import (
    String, Integer, DateTime, ForeignKey, Enum, Boolean,
    UniqueConstraint, Index, Numeric, Text
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


class Base(DeclarativeBase):
    pass


class SessionStatus(str, enum.Enum):
    OPEN = "OPEN"
    PAYING = "PAYING"
    CLOSED = "CLOSED"


class OrderStatus(str, enum.Enum):
    DRAFT = "DRAFT"
    SENT = "SENT"
    CANCELLED = "CANCELLED"


class RoundStatus(str, enum.Enum):
    OPEN = "OPEN"
    SENT = "SENT"
    LOCKED = "LOCKED"


class PaymentMethod(str, enum.Enum):
    CASH = "CASH"
    MP = "MP"  # MercadoPago (dejamos el esqueleto)


class Branch(Base):
    __tablename__ = "branch"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    slug: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    name: Mapped[str] = mapped_column(String(120))

    tables: Mapped[List["Table"]] = relationship(back_populates="branch")


class Table(Base):
    __tablename__ = "table"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    branch_id: Mapped[int] = mapped_column(ForeignKey("branch.id", ondelete="CASCADE"), index=True)
    slug: Mapped[str] = mapped_column(String(64))  # ej: "m-07"
    label: Mapped[str] = mapped_column(String(120), default="")

    branch: Mapped["Branch"] = relationship(back_populates="tables")
    sessions: Mapped[List["TableSession"]] = relationship(back_populates="table")

    __table_args__ = (
        UniqueConstraint("branch_id", "slug", name="uq_table_branch_slug"),
        Index("ix_table_branch_slug", "branch_id", "slug"),
    )


class TableSession(Base):
    __tablename__ = "table_session"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    table_id: Mapped[int] = mapped_column(ForeignKey("table.id", ondelete="CASCADE"), index=True)

    status: Mapped[SessionStatus] = mapped_column(Enum(SessionStatus), default=SessionStatus.OPEN, index=True)
    opened_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)
    closed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    # token_hash (no guardes token en claro)
    token_hash: Mapped[str] = mapped_column(String(128), unique=True, index=True)

    table: Mapped["Table"] = relationship(back_populates="sessions")
    diners: Mapped[List["Diner"]] = relationship(back_populates="session")
    rounds: Mapped[List["Round"]] = relationship(back_populates="session")
    orders: Mapped[List["Order"]] = relationship(back_populates="session")
    charges: Mapped[List["Charge"]] = relationship(back_populates="session")
    payments: Mapped[List["Payment"]] = relationship(back_populates="session")


class Diner(Base):
    __tablename__ = "diner"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    display_name: Mapped[str] = mapped_column(String(80), default="Invitado")
    joined_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)

    # opcional, para "re-join" desde mismo dispositivo sin login
    device_hash: Mapped[Optional[str]] = mapped_column(String(128), nullable=True, index=True)

    session: Mapped["TableSession"] = relationship(back_populates="diners")
    orders: Mapped[List["Order"]] = relationship(back_populates="diner")
    charges: Mapped[List["Charge"]] = relationship(back_populates="diner")
    payments: Mapped[List["Payment"]] = relationship(back_populates="payer_diner")


class Round(Base):
    __tablename__ = "round"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    number: Mapped[int] = mapped_column(Integer)
    status: Mapped[RoundStatus] = mapped_column(Enum(RoundStatus), default=RoundStatus.OPEN)
    opened_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)
    closed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    session: Mapped["TableSession"] = relationship(back_populates="rounds")
    orders: Mapped[List["Order"]] = relationship(back_populates="round")

    __table_args__ = (
        UniqueConstraint("session_id", "number", name="uq_round_session_number"),
        Index("ix_round_session_status", "session_id", "status"),
    )


class Order(Base):
    __tablename__ = "order"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    round_id: Mapped[int] = mapped_column(ForeignKey("round.id", ondelete="RESTRICT"), index=True)
    diner_id: Mapped[int] = mapped_column(ForeignKey("diner.id", ondelete="RESTRICT"), index=True)

    status: Mapped[OrderStatus] = mapped_column(Enum(OrderStatus), default=OrderStatus.DRAFT, index=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)
    sent_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    session: Mapped["TableSession"] = relationship(back_populates="orders")
    round: Mapped["Round"] = relationship(back_populates="orders")
    diner: Mapped["Diner"] = relationship(back_populates="orders")
    items: Mapped[List["OrderItem"]] = relationship(back_populates="order", cascade="all, delete-orphan")


class OrderItem(Base):
    __tablename__ = "order_item"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    order_id: Mapped[int] = mapped_column(ForeignKey("order.id", ondelete="CASCADE"), index=True)

    menu_item_id: Mapped[int] = mapped_column(Integer)  # referenciá tu tabla real de menú
    name_snapshot: Mapped[str] = mapped_column(String(180))  # snapshot del nombre
    qty: Mapped[int] = mapped_column(Integer, default=1)
    unit_price: Mapped[float] = mapped_column(Numeric(12, 2))
    notes: Mapped[str] = mapped_column(Text, default="")
    is_void: Mapped[bool] = mapped_column(Boolean, default=False)

    order: Mapped["Order"] = relationship(back_populates="items")


class Charge(Base):
    """
    “Cargo contable”: nace cuando una orden pasa a SENT.
    """
    __tablename__ = "charge"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    diner_id: Mapped[int] = mapped_column(ForeignKey("diner.id", ondelete="RESTRICT"), index=True)
    order_item_id: Mapped[int] = mapped_column(ForeignKey("order_item.id", ondelete="RESTRICT"), index=True)

    amount: Mapped[float] = mapped_column(Numeric(12, 2))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)

    session: Mapped["TableSession"] = relationship(back_populates="charges")
    diner: Mapped["Diner"] = relationship(back_populates="charges")
    allocations: Mapped[List["Allocation"]] = relationship(back_populates="charge")


class Payment(Base):
    __tablename__ = "payment"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    payer_diner_id: Mapped[Optional[int]] = mapped_column(ForeignKey("diner.id", ondelete="SET NULL"), nullable=True)

    method: Mapped[PaymentMethod] = mapped_column(Enum(PaymentMethod), index=True)
    amount: Mapped[float] = mapped_column(Numeric(12, 2))
    status: Mapped[str] = mapped_column(String(24), default="CONFIRMED")  # CASH confirmado por mozo; MP por webhook
    external_ref: Mapped[Optional[str]] = mapped_column(String(120), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)

    session: Mapped["TableSession"] = relationship(back_populates="payments")
    payer_diner: Mapped[Optional["Diner"]] = relationship(back_populates="payments")
    allocations: Mapped[List["Allocation"]] = relationship(back_populates="payment", cascade="all, delete-orphan")


class Allocation(Base):
    """
    Cómo se reparte un pago sobre cargos. Permite:
    - pagar lo propio (allocations a charges del diner)
    - pago total (alloc a cualquier charge)
    - aportes libres (alloc FIFO a lo pendiente)
    """
    __tablename__ = "allocation"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    payment_id: Mapped[int] = mapped_column(ForeignKey("payment.id", ondelete="CASCADE"), index=True)
    charge_id: Mapped[int] = mapped_column(ForeignKey("charge.id", ondelete="RESTRICT"), index=True)
    amount: Mapped[float] = mapped_column(Numeric(12, 2))

    payment: Mapped["Payment"] = relationship(back_populates="allocations")
    charge: Mapped["Charge"] = relationship(back_populates="allocations")
2) Schemas Pydantic (v2)
# app/schemas.py
from __future__ import annotations
from typing import Optional, List
from pydantic import BaseModel, Field


class JoinSessionIn(BaseModel):
    token: str
    display_name: str = "Invitado"
    device_hash: Optional[str] = None


class JoinSessionOut(BaseModel):
    session_id: int
    diner_id: int
    status: str


class OrderItemUpsert(BaseModel):
    menu_item_id: int
    name_snapshot: str
    qty: int = Field(ge=1)
    unit_price: float = Field(ge=0)
    notes: str = ""


class CreateDraftIn(BaseModel):
    session_id: int
    diner_id: int


class CreateDraftOut(BaseModel):
    order_id: int
    round_number: int
    status: str


class UpdateItemsIn(BaseModel):
    items: List[OrderItemUpsert]


class SendOrderOut(BaseModel):
    order_id: int
    charges_created: int


class CashPaymentIn(BaseModel):
    session_id: int
    payer_diner_id: Optional[int] = None
    amount: float = Field(gt=0)


class PaymentOut(BaseModel):
    payment_id: int
    amount: float
    allocations: int


class SessionStateOut(BaseModel):
    session_id: int
    status: str
    total_charges: float
    total_paid: float
    balance_due: float
    per_diner_due: list[dict]
3) Servicios: hash token + allocation FIFO
# app/services.py
from __future__ import annotations
import hashlib
from decimal import Decimal
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import Charge, Allocation


def hash_token(token: str) -> str:
    return hashlib.sha256(token.encode("utf-8")).hexdigest()


async def allocate_payment_fifo(
    db: AsyncSession,
    payment_id: int,
    session_id: int,
    amount: Decimal,
    restrict_to_diner_id: int | None = None,
) -> int:
    """
    Reparte un pago sobre cargos pendientes (FIFO por created_at).
    Si restrict_to_diner_id está seteado: paga “lo mío” primero/solo.
    Retorna cantidad de allocations creadas.
    """
    # subquery: total asignado por charge
    alloc_sum = (
        select(
            Allocation.charge_id.label("charge_id"),
            func.coalesce(func.sum(Allocation.amount), 0).label("allocated")
        )
        .group_by(Allocation.charge_id)
        .subquery()
    )

    q = (
        select(
            Charge.id,
            Charge.amount,
            func.coalesce(alloc_sum.c.allocated, 0).label("allocated")
        )
        .outerjoin(alloc_sum, alloc_sum.c.charge_id == Charge.id)
        .where(Charge.session_id == session_id)
        .order_by(Charge.created_at.asc(), Charge.id.asc())
    )

    if restrict_to_diner_id is not None:
        q = q.where(Charge.diner_id == restrict_to_diner_id)

    rows = (await db.execute(q)).all()

    remaining = amount
    created = 0

    for charge_id, charge_amount, allocated in rows:
        if remaining <= 0:
            break

        charge_amount = Decimal(charge_amount)
        allocated = Decimal(allocated)
        pending = charge_amount - allocated
        if pending <= 0:
            continue

        use = pending if pending <= remaining else remaining
        db.add(Allocation(payment_id=payment_id, charge_id=charge_id, amount=use))
        remaining -= use
        created += 1

    return created
4) Endpoints FastAPI
# app/main.py
from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.db import get_db
from app.models import (
    TableSession, Diner, Round, Order, OrderItem, Charge, Payment,
    SessionStatus, OrderStatus, RoundStatus, PaymentMethod, Allocation
)
from app.schemas import (
    JoinSessionIn, JoinSessionOut,
    CreateDraftIn, CreateDraftOut,
    UpdateItemsIn, SendOrderOut,
    CashPaymentIn, PaymentOut,
    SessionStateOut
)
from app.services import hash_token, allocate_payment_fifo

app = FastAPI(title="PWA Menu Backend")


@app.post("/sessions/join", response_model=JoinSessionOut)
async def join_session(payload: JoinSessionIn, db: AsyncSession = Depends(get_db)):
    token_hash = hash_token(payload.token)

    session = (await db.execute(
        select(TableSession).where(TableSession.token_hash == token_hash)
    )).scalar_one_or_none()

    if not session:
        raise HTTPException(status_code=404, detail="Invalid token / session not found")
    if session.status == SessionStatus.CLOSED:
        raise HTTPException(status_code=409, detail="Session is closed")

    # rejoin por device_hash si viene
    diner = None
    if payload.device_hash:
        diner = (await db.execute(
            select(Diner).where(
                Diner.session_id == session.id,
                Diner.device_hash == payload.device_hash
            )
        )).scalar_one_or_none()

    if not diner:
        diner = Diner(
            session_id=session.id,
            display_name=payload.display_name or "Invitado",
            device_hash=payload.device_hash
        )
        db.add(diner)
        await db.flush()

    await db.commit()
    return JoinSessionOut(session_id=session.id, diner_id=diner.id, status=session.status.value)


async def _get_or_create_open_round(db: AsyncSession, session_id: int) -> Round:
    r = (await db.execute(
        select(Round).where(Round.session_id == session_id, Round.status == RoundStatus.OPEN)
        .order_by(Round.number.desc())
    )).scalar_one_or_none()

    if r:
        return r

    max_num = (await db.execute(
        select(func.coalesce(func.max(Round.number), 0)).where(Round.session_id == session_id)
    )).scalar_one()

    r = Round(session_id=session_id, number=int(max_num) + 1, status=RoundStatus.OPEN)
    db.add(r)
    await db.flush()
    return r


@app.post("/orders/draft", response_model=CreateDraftOut)
async def create_or_get_draft(payload: CreateDraftIn, db: AsyncSession = Depends(get_db)):
    session = (await db.execute(
        select(TableSession).where(TableSession.id == payload.session_id)
    )).scalar_one_or_none()
    if not session:
        raise HTTPException(404, "Session not found")
    if session.status == SessionStatus.CLOSED:
        raise HTTPException(409, "Session closed")

    diner = (await db.execute(
        select(Diner).where(Diner.id == payload.diner_id, Diner.session_id == payload.session_id)
    )).scalar_one_or_none()
    if not diner:
        raise HTTPException(404, "Diner not found in this session")

    rnd = await _get_or_create_open_round(db, payload.session_id)

    order = (await db.execute(
        select(Order).where(
            Order.session_id == payload.session_id,
            Order.diner_id == payload.diner_id,
            Order.round_id == rnd.id,
            Order.status == OrderStatus.DRAFT
        )
    )).scalar_one_or_none()

    if not order:
        order = Order(session_id=payload.session_id, round_id=rnd.id, diner_id=payload.diner_id)
        db.add(order)
        await db.flush()

    await db.commit()
    return CreateDraftOut(order_id=order.id, round_number=rnd.number, status=order.status.value)


@app.put("/orders/{order_id}/items", response_model=dict)
async def replace_order_items(order_id: int, payload: UpdateItemsIn, db: AsyncSession = Depends(get_db)):
    order = (await db.execute(select(Order).where(Order.id == order_id))).scalar_one_or_none()
    if not order:
        raise HTTPException(404, "Order not found")
    if order.status != OrderStatus.DRAFT:
        raise HTTPException(409, "Only DRAFT orders can be modified")

    # borrar items actuales y recrear (simple, robusto)
    await db.execute(
        OrderItem.__table__.delete().where(OrderItem.order_id == order_id)
    )

    for it in payload.items:
        db.add(OrderItem(
            order_id=order_id,
            menu_item_id=it.menu_item_id,
            name_snapshot=it.name_snapshot,
            qty=it.qty,
            unit_price=it.unit_price,
            notes=it.notes
        ))

    await db.commit()
    return {"ok": True, "items": len(payload.items)}


@app.post("/orders/{order_id}/send", response_model=SendOrderOut)
async def send_order(order_id: int, db: AsyncSession = Depends(get_db)):
    order = (await db.execute(select(Order).where(Order.id == order_id))).scalar_one_or_none()
    if not order:
        raise HTTPException(404, "Order not found")
    if order.status != OrderStatus.DRAFT:
        raise HTTPException(409, "Order is not DRAFT")

    items = (await db.execute(select(OrderItem).where(OrderItem.order_id == order_id))).scalars().all()
    if not items:
        raise HTTPException(400, "Order has no items")

    # marcar orden como enviada
    order.status = OrderStatus.SENT
    order.sent_at = datetime.utcnow()

    # crear cargos contables por item (qty * unit_price)
    created = 0
    for it in items:
        if it.is_void:
            continue
        amount = Decimal(str(it.qty)) * Decimal(str(it.unit_price))
        db.add(Charge(
            session_id=order.session_id,
            diner_id=order.diner_id,
            order_item_id=it.id,
            amount=amount
        ))
        created += 1

    # opcional: si la ronda está OPEN, podés dejarla; o cerrarla cuando el mozo "manda a cocina"
    await db.commit()
    return SendOrderOut(order_id=order.id, charges_created=created)


@app.post("/payments/cash", response_model=PaymentOut)
async def register_cash_payment(payload: CashPaymentIn, db: AsyncSession = Depends(get_db)):
    session = (await db.execute(select(TableSession).where(TableSession.id == payload.session_id))).scalar_one_or_none()
    if not session:
        raise HTTPException(404, "Session not found")
    if session.status == SessionStatus.CLOSED:
        raise HTTPException(409, "Session closed")

    pay = Payment(
        session_id=payload.session_id,
        payer_diner_id=payload.payer_diner_id,
        method=PaymentMethod.CASH,
        amount=Decimal(str(payload.amount)),
        status="CONFIRMED",
        external_ref=None
    )
    db.add(pay)
    await db.flush()

    # aportes libres por defecto (FIFO). Si querés "pago lo mío":
    # pasá restrict_to_diner_id=payload.payer_diner_id
    allocations_created = await allocate_payment_fifo(
        db=db,
        payment_id=pay.id,
        session_id=payload.session_id,
        amount=Decimal(str(payload.amount)),
        restrict_to_diner_id=None
    )

    # si entra plata, marcamos sesión como PAYING si estaba OPEN
    if session.status == SessionStatus.OPEN:
        session.status = SessionStatus.PAYING

    await db.commit()
    return PaymentOut(payment_id=pay.id, amount=float(pay.amount), allocations=allocations_created)


@app.get("/sessions/{session_id}/state", response_model=SessionStateOut)
async def session_state(session_id: int, db: AsyncSession = Depends(get_db)):
    session = (await db.execute(select(TableSession).where(TableSession.id == session_id))).scalar_one_or_none()
    if not session:
        raise HTTPException(404, "Session not found")

    total_charges = (await db.execute(
        select(func.coalesce(func.sum(Charge.amount), 0)).where(Charge.session_id == session_id)
    )).scalar_one()

    total_paid = (await db.execute(
        select(func.coalesce(func.sum(Payment.amount), 0))
        .where(Payment.session_id == session_id, Payment.status == "CONFIRMED")
    )).scalar_one()

    # deuda por comensal = cargos - allocs sobre cargos de ese diner
    alloc_sum = (
        select(
            Charge.diner_id.label("diner_id"),
            func.coalesce(func.sum(Allocation.amount), 0).label("allocated")
        )
        .join(Allocation, Allocation.charge_id == Charge.id)
        .where(Charge.session_id == session_id)
        .group_by(Charge.diner_id)
        .subquery()
    )

    charges_by = (
        select(
            Charge.diner_id,
            func.coalesce(func.sum(Charge.amount), 0).label("charged"),
            func.coalesce(alloc_sum.c.allocated, 0).label("allocated")
        )
        .outerjoin(alloc_sum, alloc_sum.c.diner_id == Charge.diner_id)
        .where(Charge.session_id == session_id)
        .group_by(Charge.diner_id, alloc_sum.c.allocated)
    )
    rows = (await db.execute(charges_by)).all()

    per_diner = []
    for diner_id, charged, allocated in rows:
        due = Decimal(charged) - Decimal(allocated)
        per_diner.append({
            "diner_id": int(diner_id),
            "charged": float(charged),
            "paid_allocated": float(allocated),
            "due": float(due)
        })

    balance_due = Decimal(total_charges) - Decimal(total_paid)

    return SessionStateOut(
        session_id=session_id,
        status=session.status.value,
        total_charges=float(total_charges),
        total_paid=float(total_paid),
        balance_due=float(balance_due),
        per_diner_due=per_diner
    )


@app.post("/sessions/{session_id}/close", response_model=dict)
async def close_session(session_id: int, db: AsyncSession = Depends(get_db)):
    session = (await db.execute(select(TableSession).where(TableSession.id == session_id))).scalar_one_or_none()
    if not session:
        raise HTTPException(404, "Session not found")
    if session.status == SessionStatus.CLOSED:
        return {"ok": True, "status": "CLOSED"}

    total_charges = Decimal((await db.execute(
        select(func.coalesce(func.sum(Charge.amount), 0)).where(Charge.session_id == session_id)
    )).scalar_one())

    total_paid = Decimal((await db.execute(
        select(func.coalesce(func.sum(Payment.amount), 0))
        .where(Payment.session_id == session_id, Payment.status == "CONFIRMED")
    )).scalar_one())

    if total_charges - total_paid != 0:
        raise HTTPException(409, "Cannot close: balance_due != 0")

    session.status = SessionStatus.CLOSED
    session.closed_at = datetime.utcnow()
    await db.commit()
    return {"ok": True, "status": "CLOSED"}
5) Cómo lo usás desde React (flujo mínimo)
Escaneo QR → POST /sessions/join con { token, display_name, device_hash }

Guardás { session_id, diner_id } en localStorage

POST /orders/draft para obtener order_id

PUT /orders/{order_id}/items

POST /orders/{order_id}/send

GET /sessions/{session_id}/state para ver saldo/por comensal

POST /payments/cash (solo mozo) o luego agregamos MercadoPago

6) Lo que falta para que quede “productivo”
Si querés, en el próximo paso te lo completo con:

Alembic (migraciones) + índices recomendados

WebSocket (/ws/sessions/{id}) para que el “carrito/cuenta” sea realmente live

Mercado Pago: create_preference + webhook + Payment.method=MP + allocation al confirmar

Seguridad del QR: token JWT firmado + expiración + rotación por sesión

Decime cuál de estos querés primero (yo arrancaría por WebSocket + eventos porque es lo que te da el “carrito compartido online” de verdad).

Tú dijiste:
quiero todos
ChatGPT Plus

Pensó durante 15s
Perfecto. Te lo dejo completo: Alembic (migraciones), WebSocket (eventos live), Mercado Pago (Checkout Pro: preference + webhook) y seguridad del QR con JWT + rotación por sesión. Todo compatible con FastAPI + Postgres + SQLAlchemy 2.0 async.

Nota: la documentación de Mercado Pago para Checkout Pro usa el endpoint de Preferences y notificaciones por Webhooks (con Access Token por header). 

A) Alembic (migraciones)
1) Dependencias
pip install alembic sqlalchemy asyncpg
2) Estructura mínima
app/
  db.py
  models.py
  main.py
alembic.ini
alembic/
  env.py
  versions/
3) alembic.ini (lo importante)
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://user:pass@localhost:5432/pwamenu
4) alembic/env.py (async)
from __future__ import annotations
import asyncio
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine

from app.models import Base  # importa tus modelos para metadata

config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True)
    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online():
    connectable = create_async_engine(
        config.get_main_option("sqlalchemy.url"),
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(
            lambda sync_conn: context.configure(
                connection=sync_conn,
                target_metadata=target_metadata,
                compare_type=True,
            )
        )
        with context.begin_transaction():
            await connection.run_sync(lambda _: context.run_migrations())

    await connectable.dispose()

def run():
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        asyncio.run(run_migrations_online())

run()
5) Crear primera migración
alembic revision --autogenerate -m "init"
alembic upgrade head
B) QR seguro (JWT) + rotación por sesión
Idea
El QR contiene un JWT firmado (HS256) con:

sid (session_id)

tid (table_id)

bid (branch_id)

iat, exp

jti (nonce)

En DB guardás hash del jti (token_hash) para revocar/rotar.

Cuando “abrís mesa”, generás un nuevo JWT (rotación) y actualizás token_hash.

1) Utilidad JWT
# app/security.py
from __future__ import annotations
import hashlib, time, uuid
import jwt  # pip install pyjwt
from pydantic import BaseModel

JWT_SECRET = "CHANGE_ME"
JWT_ALG = "HS256"
JWT_TTL_SECONDS = 60 * 60 * 6  # 6h, ajustá a tu operación

def sha256(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

class QrClaims(BaseModel):
    sid: int
    tid: int
    bid: int
    jti: str
    iat: int
    exp: int

def mint_qr_jwt(session_id: int, table_id: int, branch_id: int) -> tuple[str, str]:
    now = int(time.time())
    jti = str(uuid.uuid4())
    payload = {
        "sid": session_id,
        "tid": table_id,
        "bid": branch_id,
        "jti": jti,
        "iat": now,
        "exp": now + JWT_TTL_SECONDS,
    }
    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)
    return token, sha256(jti)

def verify_qr_jwt(token: str) -> QrClaims:
    data = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALG])
    return QrClaims(**data)
2) Ajuste en modelo TableSession
En tu TableSession ya tenés token_hash. Ahora ese token_hash será el hash del jti.

3) Join seguro (reemplaza tu join anterior)
# dentro de app/main.py (endpoint join)
from app.security import verify_qr_jwt, sha256

@app.post("/sessions/join")
async def join_session(payload: JoinSessionIn, db: AsyncSession = Depends(get_db)):
    claims = verify_qr_jwt(payload.token)  # valida firma/exp
    session = (await db.execute(
        select(TableSession).where(TableSession.id == claims.sid)
    )).scalar_one_or_none()

    if not session or session.status == SessionStatus.CLOSED:
        raise HTTPException(404, "Session not found/closed")

    # revocación/rotación: jti debe coincidir con token_hash almacenado
    if session.token_hash != sha256(claims.jti):
        raise HTTPException(409, "QR expired/rotated (invalid token jti)")

    # ... resto igual (rejoin por device_hash, etc.)
C) WebSocket “carrito/cuenta live”
1) Connection Manager (in-process)
Esto es perfecto para 1 instancia. Para escalar a varias, cambiás el “broadcast” por Redis Pub/Sub (misma interfaz).

# app/ws.py
from __future__ import annotations
from collections import defaultdict
from typing import Dict, Set
from fastapi import WebSocket

class WSManager:
    def __init__(self) -> None:
        self._sessions: Dict[int, Set[WebSocket]] = defaultdict(set)

    async def connect(self, session_id: int, ws: WebSocket) -> None:
        await ws.accept()
        self._sessions[session_id].add(ws)

    def disconnect(self, session_id: int, ws: WebSocket) -> None:
        self._sessions[session_id].discard(ws)

    async def broadcast(self, session_id: int, event: dict) -> None:
        dead = []
        for ws in self._sessions[session_id]:
            try:
                await ws.send_json(event)
            except Exception:
                dead.append(ws)
        for ws in dead:
            self._sessions[session_id].discard(ws)

ws_manager = WSManager()
2) WebSocket endpoint
from app.ws import ws_manager
from app.security import verify_qr_jwt, sha256

@app.websocket("/ws")
async def ws_endpoint(ws: WebSocket, token: str):
    # token es el mismo JWT del QR (o uno derivado para WS)
    claims = verify_qr_jwt(token)
    # opcional: validación contra DB (token_hash), igual que join
    await ws_manager.connect(claims.sid, ws)
    try:
        # WS server-push: no hace falta recibir nada
        while True:
            await ws.receive_text()
    except Exception:
        pass
    finally:
        ws_manager.disconnect(claims.sid, ws)
3) Emitir eventos cuando cambia algo
En send_order al final:

await ws_manager.broadcast(order.session_id, {
    "type": "order_sent",
    "order_id": order.id,
    "diner_id": order.diner_id,
    "round_id": order.round_id,
})
await ws_manager.broadcast(order.session_id, {
    "type": "state_changed",
})
En register_cash_payment al confirmar:

await ws_manager.broadcast(payload.session_id, {
    "type": "payment_confirmed",
    "method": "CASH",
    "amount": float(pay.amount),
    "payment_id": pay.id,
})
await ws_manager.broadcast(payload.session_id, {"type": "state_changed"})
En React: cuando llegue state_changed, llamás GET /sessions/{id}/state y refrescás UI.

D) Mercado Pago (Checkout Pro): preference + webhook + allocación
Mercado Pago recomienda enviar el Access Token por Authorization header. 

Para Checkout Pro, creás una preference y recibís notificaciones por webhooks/payment notifications. 

1) Modelo extra mínimo: PaymentIntent
(para trackear “qué intentamos cobrar” + modo split)

# app/models_mp.py (o agregalo a models.py)
from sqlalchemy import String, Integer, DateTime, ForeignKey, Enum, Numeric
from sqlalchemy.orm import Mapped, mapped_column, relationship
from datetime import datetime
import enum

class SplitMode(str, enum.Enum):
    SESSION = "SESSION"   # uno paga todo / aportes libres sobre toda la mesa
    DINER = "DINER"       # paga lo suyo

class PaymentIntent(Base):
    __tablename__ = "payment_intent"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    payer_diner_id: Mapped[int | None] = mapped_column(ForeignKey("diner.id", ondelete="SET NULL"), nullable=True)

    provider: Mapped[str] = mapped_column(String(16), default="MP")
    split_mode: Mapped[SplitMode] = mapped_column(Enum(SplitMode), default=SplitMode.SESSION)

    amount: Mapped[float] = mapped_column(Numeric(12,2))
    status: Mapped[str] = mapped_column(String(24), default="CREATED")  # CREATED|PAID|CANCELLED

    # referencia para MP
    preference_id: Mapped[str | None] = mapped_column(String(80), nullable=True)
    external_reference: Mapped[str] = mapped_column(String(120), unique=True, index=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)
2) Cliente MP (requests/httpx)
# app/mp_client.py
from __future__ import annotations
import httpx

MP_ACCESS_TOKEN = "TEST-..."  # usa env var en prod
MP_BASE = "https://api.mercadopago.com"

async def mp_create_preference(payload: dict) -> dict:
    headers = {"Authorization": f"Bearer {MP_ACCESS_TOKEN}"}
    async with httpx.AsyncClient(timeout=15) as client:
        r = await client.post(f"{MP_BASE}/checkout/preferences", json=payload, headers=headers)
        r.raise_for_status()
        return r.json()

async def mp_get_payment(payment_id: str) -> dict:
    headers = {"Authorization": f"Bearer {MP_ACCESS_TOKEN}"}
    async with httpx.AsyncClient(timeout=15) as client:
        r = await client.get(f"{MP_BASE}/v1/payments/{payment_id}", headers=headers)
        r.raise_for_status()
        return r.json()
3) Endpoint: crear preference para pagar (por mesa o por comensal)
# app/schemas_mp.py
from pydantic import BaseModel, Field
from typing import Optional, Literal

class MpPreferenceIn(BaseModel):
    session_id: int
    payer_diner_id: Optional[int] = None
    amount: float = Field(gt=0)
    split_mode: Literal["SESSION","DINER"] = "SESSION"
    title: str = "Consumo mesa"

class MpPreferenceOut(BaseModel):
    init_point: str
    preference_id: str
    external_reference: str
# en app/main.py
import uuid
from app.mp_client import mp_create_preference
from app.models_mp import PaymentIntent, SplitMode

@app.post("/payments/mp/preference", response_model=MpPreferenceOut)
async def create_mp_preference(payload: MpPreferenceIn, db: AsyncSession = Depends(get_db)):
    # 1) crear PaymentIntent local
    ext_ref = f"sess:{payload.session_id}:pi:{uuid.uuid4()}"
    pi = PaymentIntent(
        session_id=payload.session_id,
        payer_diner_id=payload.payer_diner_id,
        amount=Decimal(str(payload.amount)),
        split_mode=SplitMode.DINER if payload.split_mode == "DINER" else SplitMode.SESSION,
        external_reference=ext_ref,
    )
    db.add(pi)
    await db.flush()

    # 2) armar preference (Checkout Pro)
    # IMPORTANT: external_reference sirve para reconciliar en webhook.
    pref_payload = {
        "items": [{
            "title": payload.title,
            "quantity": 1,
            "unit_price": float(payload.amount),
        }],
        "external_reference": ext_ref,
        # Opcional: back_urls, auto_return, notification_url (webhook)
        # "notification_url": "https://tu-dominio.com/payments/mp/webhook",
    }

    pref = await mp_create_preference(pref_payload)
    pi.preference_id = pref.get("id")
    await db.commit()

    return MpPreferenceOut(
        init_point=pref["init_point"],
        preference_id=pref["id"],
        external_reference=ext_ref,
    )
4) Webhook MP → confirmar pago + Allocation
Mercado Pago tiene docs de Webhooks/Notifications para enterarte de pagos creados/actualizados. 

from fastapi import Request
from app.mp_client import mp_get_payment
from app.models_mp import PaymentIntent, SplitMode

@app.post("/payments/mp/webhook")
async def mp_webhook(request: Request, db: AsyncSession = Depends(get_db)):
    # MP manda distintos formatos según evento/config. Guardá raw por auditoría.
    body = await request.json()

    # caso típico: body trae un data.id (payment_id) o "id"
    payment_id = None
    if isinstance(body, dict):
        payment_id = body.get("data", {}).get("id") or body.get("id")

    if not payment_id:
        return {"ok": True}  # no rompemos webhook

    payment = await mp_get_payment(str(payment_id))
    status = payment.get("status")  # approved, rejected, etc.

    if status != "approved":
        return {"ok": True, "status": status}

    ext_ref = payment.get("external_reference")
    amount = Decimal(str(payment.get("transaction_amount", "0")))

    # 1) buscar PaymentIntent
    pi = (await db.execute(
        select(PaymentIntent).where(PaymentIntent.external_reference == ext_ref)
    )).scalar_one_or_none()
    if not pi:
        return {"ok": True, "warn": "PaymentIntent not found"}

    if pi.status == "PAID":
        return {"ok": True, "status": "already_paid"}

    # 2) crear Payment local
    pay = Payment(
        session_id=pi.session_id,
        payer_diner_id=pi.payer_diner_id,
        method=PaymentMethod.MP,
        amount=amount,
        status="CONFIRMED",
        external_ref=str(payment_id),
    )
    db.add(pay)
    await db.flush()

    # 3) allocation según split_mode
    restrict = pi.payer_diner_id if pi.split_mode == SplitMode.DINER else None
    allocations_created = await allocate_payment_fifo(
        db=db,
        payment_id=pay.id,
        session_id=pi.session_id,
        amount=amount,
        restrict_to_diner_id=restrict,
    )

    pi.status = "PAID"
    await db.commit()

    # 4) evento realtime (si querés)
    await ws_manager.broadcast(pi.session_id, {
        "type": "payment_confirmed",
        "method": "MP",
        "amount": float(amount),
        "payment_id": pay.id,
    })
    await ws_manager.broadcast(pi.session_id, {"type": "state_changed"})

    return {"ok": True, "allocations": allocations_created}
Importante en producción: validá origen del webhook con el mecanismo de firma/secret que provee MP cuando configurás Webhooks (según tu panel/config). 

E) “Todos los modos de pago” con este diseño (cómo se usa)
Uno paga todo

Front pide GET /sessions/{id}/state → balance_due

Crea preference con split_mode=SESSION, amount=balance_due

Cada uno paga lo suyo

UI muestra per_diner_due[diner_id].due

Cada uno crea preference con split_mode=DINER, payer_diner_id=..., amount=su_due

Aportes libres (MP + cash mezclado)

Cada pago entra como split_mode=SESSION

FIFO allocation va cancelando cargos pendientes hasta completar

F) Extras críticos que te recomiendo agregar (rápidos)
Idempotencia en webhook: guardá external_ref + payment_id como únicos para no duplicar pagos.

Redondeos: usá Decimal y define política (2 decimales).

Permisos: POST /payments/cash solo mozo/admin.

Escala WS: si vas a múltiples instancias → Redis Pub/Sub y listo.

Si querés, te lo dejo también con:

docker-compose.yml (Postgres + backend)

alembic ya inicializado y una migración “init” generada

un mini “SDK” para React (hooks useSessionState, useSessionWS, useDraftOrder)

Decime si estás corriendo async (como está arriba) o preferís sync (simplifica, pero pierde concurrencia en I/O).

Tú dijiste:
esta aplicacion tiene un ngnx antes de llegar al bckend, es que varia toda la aplicacion?
ChatGPT Plus
No te cambia “toda la aplicación”, pero sí te cambia algunas piezas importantes (sobre todo WebSocket, webhooks de Mercado Pago, CORS/headers, TLS, y ruteo). El backend FastAPI y el modelo de datos quedan igual; lo que cambia es cómo entra el tráfico y qué tenés que configurar para que no se rompa.

Qué cosas cambia Nginx en tu caso
1) WebSocket (carrito live)
Si ponés Nginx delante y no lo configurás, el WS suele fallar (se queda “connecting” o corta).

Necesitás estas cabeceras:

Upgrade

Connection: upgrade

proxy_http_version 1.1

2) Mercado Pago webhook
Mercado Pago tiene que pegarle a una URL pública (HTTPS). Con Nginx:

terminás TLS en Nginx (recomendado)

y ruteás /payments/mp/webhook al backend

Además: Nginx tiene que permitir el body y no bloquear por tamaño o WAF.

3) Tamaño de requests (PDF / imágenes / payloads grandes)
Si subís archivos o mandás JSON grande:

client_max_body_size en Nginx

y timeouts adecuados

4) CORS / headers / host
Si el frontend (PWA) y el backend van por dominios distintos, CORS se maneja en FastAPI, pero Nginx puede:

agregar headers

forzar HTTPS

cachear estáticos

reescribir rutas

5) Rutas / reverse proxy
La app no cambia, pero tus URLs sí:

/api/... hacia FastAPI

/ws para WebSocket

/ puede servir el build de React o ir a otro host (Vercel, etc.)

Config Nginx típica para tu arquitectura (API + WS + Webhook)
Suponiendo:

Front en https://menu.tudominio.com

API en https://menu.tudominio.com/api

WS en wss://menu.tudominio.com/ws

FastAPI corriendo en http://127.0.0.1:8000

server {
    listen 443 ssl;
    server_name menu.tudominio.com;

    # SSL (certbot / letsencrypt)
    ssl_certificate     /etc/letsencrypt/live/menu.tudominio.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/menu.tudominio.com/privkey.pem;

    # Si subís cosas (pdf), ajustá:
    client_max_body_size 20m;

    # --- API ---
    location /api/ {
        proxy_pass http://127.0.0.1:8000/;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # timeouts razonables
        proxy_connect_timeout 10s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # --- Webhook MP (podés dejarlo dentro de /api también) ---
    # si tu endpoint es /payments/mp/webhook en FastAPI:
    location /payments/mp/webhook {
        proxy_pass http://127.0.0.1:8000/payments/mp/webhook;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_read_timeout 60s;
    }

    # --- WebSocket ---
    location /ws {
        proxy_pass http://127.0.0.1:8000/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # --- Frontend estático (opcional si servís React desde Nginx) ---
    # location / {
    #     root /var/www/pwa;
    #     try_files $uri /index.html;
    # }
}

server {
    listen 80;
    server_name menu.tudominio.com;
    return 301 https://$host$request_uri;
}
3 puntos que te evitan bugs raros
A) FastAPI detrás de proxy: “ver HTTPS real”
Si terminás TLS en Nginx, FastAPI ve tráfico “http” a nivel interno.
Para que genere URLs correctas y/o valide cookies/secure, corré Uvicorn con:

uvicorn app.main:app --proxy-headers --forwarded-allow-ips="*"
B) Cookies / sesiones / SameSite (si usás)
Si en algún momento metés cookies, con PWA + pagos suele ser clave:

SameSite=None; Secure si hay cross-site

pero si todo está bajo el mismo dominio, mejor

C) PWA + Service Worker
Nginx puede cachear cosas que no debe. Para PWA:

cache control correcto para service-worker.js

y evitar cache agresivo en index.html

Entonces: ¿varía toda la aplicación?
No. Cambia el “borde”:

ruteo (/api, /ws, /webhook)

headers (Upgrade, Forwarded)

límites (body size)

TLS/HTTPS (wss://)

Pero tu lógica de rondas, cargos, pagos, allocations y endpoints queda igual.

Si me decís cómo lo estás desplegando (por ejemplo: Docker + Nginx, o Nginx en VM y Uvicorn/Gunicorn aparte), te dejo el nginx.conf exacto + un docker-compose.yml listo para levantar todo.

Tú dijiste:
cual es la forma mas segura de trabajajar mi backend con la aplicion pwa? cookies?
ChatGPT Plus

Pensó durante 7s
Para tu caso (PWA de mesa por QR, comensales “anónimos”, WebSocket live, pagos mixtos), la opción más segura y práctica casi siempre es:

Recomendación principal
✅ Access token corto + Refresh token en cookie HttpOnly
Access token (JWT corto, 5–15 min): lo usás en cada request (header Authorization: Bearer ...).

Refresh token (largo, rotado): lo guardás en una cookie HttpOnly + Secure (no accesible desde JS).

Cuando vence el access token: la PWA llama /auth/refresh y obtiene uno nuevo.

Por qué es lo más seguro

Evitás el peor riesgo típico de PWAs: XSS robando tokens de localStorage.

El refresh en cookie HttpOnly no se puede leer con JS aunque haya XSS.

El access token en memoria se pierde al cerrar la pestaña (bien).

¿Cookies “puras” (sesión tradicional) o JWT?
Opción A — Cookies puras (sesión server-side)
✅ Muy segura si:

tu PWA y API están en el mismo dominio (ej menu.tudominio.com)

usás cookies HttpOnly; Secure; SameSite=Lax o Strict

agregás CSRF (o SameSite=Strict si no rompe nada)

📌 Contras:

escalabilidad: necesitás store de sesiones (Redis) si tenés múltiples instancias.

WebSocket igual requiere cuidado (pero se puede con cookie).

Opción B — JWT + Refresh cookie (mi recomendación para vos)
✅ Ideal para:

WebSocket

multi-instancia

performance

control fino (expiración, rotación, revocación)

📌 Contras:

hay que implementar refresh/rotación correctamente (pero vale la pena).

Lo que NO te recomiendo (aunque se ve mucho)
❌ Guardar JWT en localStorage o sessionStorage
Porque si tenés XSS (una lib comprometida, un HTML inyectado, etc.), te roban el token y listo.

Cómo lo bajaría a tu flujo de QR (seguro)
1) QR tiene token de sesión de mesa (JWT firmado, corto)
El QR sirve solo para “join”, no para autenticar todo el tiempo.

2) POST /sessions/join
Validás el QR token (firma, exp, jti contra DB).

Creamos/recuperamos diner_id.

Devolvés:

access_token (en el body)

refresh_token (cookie HttpOnly)

Cookie ejemplo:

Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Lax; Path=/auth/refresh

3) Requests normales
Authorization: Bearer <access_token> (desde memoria, no storage)

4) Refresh
POST /auth/refresh (manda cookie automáticamente)

respuesta: nuevo access_token

y rotás refresh (refresh token rotation)

Parámetros de cookies según tu despliegue
Si PWA y API están en el mismo dominio
✅ Mejor:

Secure

HttpOnly

SameSite=Lax (o Strict si no rompe login/pagos)

Sin CORS si todo es same-origin

Si están en dominios distintos (ej PWA en Vercel y API aparte)
Vas a necesitar:

SameSite=None; Secure

CORS bien configurado

y CSRF token (porque SameSite=None abre la puerta a CSRF)

Checklist de seguridad que sí o sí te conviene
HTTPS siempre (incluye wss://).

CSP fuerte (te baja muchísimo el riesgo de XSS).

No confiar en datos del cliente (precios, totales): el server recalcula.

RBAC: comensal no puede confirmar efectivo ni cerrar sesión.

Rate limit (join, refresh, mp webhook, ws).

Validación “Origin” en endpoints sensibles (sobre todo si usás cookies).

Rotación de QR por sesión (si cambia el grupo, cambia jti/token_hash).

Respuesta directa a tu pregunta
Si me hacés elegir una sola “forma más segura”:

✅ Refresh token en cookie HttpOnly + access token corto en memoria + (CSRF si cross-site)
Eso te da un excelente balance entre seguridad real y practicidad en PWA.

Si querés, te escribo los endpoints exactos:

/auth/login-qr o /sessions/join (set cookie)

/auth/refresh (rotación)

middleware de auth (FastAPI dependency)

y la autenticación de WebSocket (token corto “ws_token” o cookie).

Tú dijiste:
quiero que ordenadamente el pedido llegue al cocinero que tendra un dashboard con la mesa y el pedido
ChatGPT Plus
Perfecto: para que al cocinero le llegue ordenado, necesitás dos cosas:

Un modelo “Kitchen Ticket” (no mostrar “órdenes crudas” del comensal, sino tickets listos para cocina).

Un canal live (WS/SSE) + un dashboard que consulte y reciba eventos.

Abajo te dejo una solución completa (backend FastAPI + endpoints + WS) y el esquema del dashboard.

1) Concepto: KDS (Kitchen Display System) con “tickets”
Cuando un comensal aprieta Enviar pedido (o el mozo confirma), vos convertís eso en un KitchenTicket con items “cocinables”.

Estados recomendados de cocina
NEW → recién ingresó

IN_PROGRESS → cocina lo está preparando

READY → listo para retirar/servir

SERVED → entregado (opcional)

CANCELLED → anulado (con motivo)

Esto te permite que el cocinero vea cola, prioridad, mesa, hora, items, notas.

2) Modelo de datos mínimo para cocina
Agregá estas tablas:

kitchen_ticket

id

session_id

table_label_snapshot (ej “M-07”)

round_number

source_order_id (opcional)

status (NEW/IN_PROGRESS/READY/SERVED/CANCELLED)

created_at

started_at, ready_at

notes (opcional)

kitchen_ticket_item

id

ticket_id

menu_item_id

name_snapshot

qty

notes

station (opcional: parrilla, ensaladas, bar)

status (si querés por ítem)

“snapshot” evita que cambie el nombre si editás el menú.

3) Flujo: de Order → KitchenTicket
Hay dos variantes:

Variante A (simple): ticket por Order enviado
Cada Order que pasa a SENT genera un KitchenTicket.

Ticket queda vinculado al diner_id (si querés) pero cocina ve mesa/ronda.

Variante B (más cocina-real): ticket por Round
Cuando se “cierra” la ronda, juntás todos los orders sent en esa ronda y generás 1 ticket por mesa/ronda.

Cocina recibe un solo bloque, ideal si “manda cocina” el mozo.

Recomendación: arrancá con A (rápida), luego migrás a B.

4) Endpoints para cocina (FastAPI)
Crear ticket automáticamente al enviar orden
En tu POST /orders/{id}/send, al final:

insertás KitchenTicket + items

emitís evento WS a “cocina”

Endpoints KDS
GET /kitchen/tickets?status=NEW&branch_id=...

GET /kitchen/tickets/{id}

POST /kitchen/tickets/{id}/start

POST /kitchen/tickets/{id}/ready

POST /kitchen/tickets/{id}/cancel

5) Código real: modelos + endpoints + WS (cocina)
Modelos (SQLAlchemy)
# app/models_kitchen.py
from __future__ import annotations
import enum
from datetime import datetime
from typing import Optional, List
from sqlalchemy import Integer, String, DateTime, ForeignKey, Enum, Text
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models import Base

class KitchenStatus(str, enum.Enum):
    NEW = "NEW"
    IN_PROGRESS = "IN_PROGRESS"
    READY = "READY"
    SERVED = "SERVED"
    CANCELLED = "CANCELLED"

class KitchenTicket(Base):
    __tablename__ = "kitchen_ticket"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("table_session.id", ondelete="CASCADE"), index=True)
    order_id: Mapped[Optional[int]] = mapped_column(ForeignKey("order.id", ondelete="SET NULL"), nullable=True, index=True)

    table_label_snapshot: Mapped[str] = mapped_column(String(64))
    round_number: Mapped[int] = mapped_column(Integer)

    status: Mapped[KitchenStatus] = mapped_column(Enum(KitchenStatus), default=KitchenStatus.NEW, index=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=datetime.utcnow)
    started_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    ready_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    notes: Mapped[str] = mapped_column(Text, default="")

    items: Mapped[List["KitchenTicketItem"]] = relationship(
        back_populates="ticket", cascade="all, delete-orphan"
    )

class KitchenTicketItem(Base):
    __tablename__ = "kitchen_ticket_item"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    ticket_id: Mapped[int] = mapped_column(ForeignKey("kitchen_ticket.id", ondelete="CASCADE"), index=True)

    menu_item_id: Mapped[int] = mapped_column(Integer)
    name_snapshot: Mapped[str] = mapped_column(String(180))
    qty: Mapped[int] = mapped_column(Integer)
    notes: Mapped[str] = mapped_column(Text, default="")
    station: Mapped[Optional[str]] = mapped_column(String(40), nullable=True)

    ticket: Mapped["KitchenTicket"] = relationship(back_populates="items")
Crear ticket en /orders/{id}/send
# en app/main.py (en send_order)
from app.models_kitchen import KitchenTicket, KitchenTicketItem
from app.ws import ws_manager
from sqlalchemy import select
from app.models import TableSession, Table, Round

# ... dentro de send_order después de crear charges

# traer label de mesa y numero de ronda
ts = (await db.execute(select(TableSession).where(TableSession.id == order.session_id))).scalar_one()
tb = (await db.execute(select(Table).where(Table.id == ts.table_id))).scalar_one()
rnd = (await db.execute(select(Round).where(Round.id == order.round_id))).scalar_one()

ticket = KitchenTicket(
    session_id=order.session_id,
    order_id=order.id,
    table_label_snapshot=tb.slug,      # o tb.label
    round_number=rnd.number,
    notes=""
)
db.add(ticket)
await db.flush()

for it in items:
    if it.is_void:
        continue
    db.add(KitchenTicketItem(
        ticket_id=ticket.id,
        menu_item_id=it.menu_item_id,
        name_snapshot=it.name_snapshot,
        qty=it.qty,
        notes=it.notes,
        station=None
    ))

await db.commit()

# evento a cocina
await ws_manager.broadcast(order.session_id, {"type": "state_changed"})  # mesa
await ws_manager.broadcast(-1, {  # usamos -1 como “canal cocina global” (ver más abajo)
    "type": "kitchen_ticket_new",
    "ticket_id": ticket.id,
    "table": ticket.table_label_snapshot,
    "round": ticket.round_number
})
Mejor: canal por sucursal kitchen:{branch_id}. Te lo dejo abajo.

6) WebSocket de cocina (canal por sucursal)
En vez de “-1”, usá un manager por branch_id:

WS: /ws/kitchen?branch_id=...&kitchen_token=...

Broadcast: ws_manager.broadcast_kitchen(branch_id, event)

Manager extendido
# app/ws.py (extendido)
from collections import defaultdict
from typing import Dict, Set
from fastapi import WebSocket

class WSManager:
    def __init__(self) -> None:
        self._sessions: Dict[int, Set[WebSocket]] = defaultdict(set)
        self._kitchen: Dict[int, Set[WebSocket]] = defaultdict(set)  # branch_id

    async def connect_session(self, session_id: int, ws: WebSocket):
        await ws.accept()
        self._sessions[session_id].add(ws)

    async def connect_kitchen(self, branch_id: int, ws: WebSocket):
        await ws.accept()
        self._kitchen[branch_id].add(ws)

    def disconnect_session(self, session_id: int, ws: WebSocket):
        self._sessions[session_id].discard(ws)

    def disconnect_kitchen(self, branch_id: int, ws: WebSocket):
        self._kitchen[branch_id].discard(ws)

    async def broadcast_session(self, session_id: int, event: dict):
        for ws in list(self._sessions[session_id]):
            try: await ws.send_json(event)
            except: self._sessions[session_id].discard(ws)

    async def broadcast_kitchen(self, branch_id: int, event: dict):
        for ws in list(self._kitchen[branch_id]):
            try: await ws.send_json(event)
            except: self._kitchen[branch_id].discard(ws)

ws_manager = WSManager()
WS endpoint cocina
@app.websocket("/ws/kitchen")
async def ws_kitchen(ws: WebSocket, branch_id: int, kitchen_token: str):
    # kitchen_token: protegelo (rol kitchen). Puede ser JWT de staff.
    # TODO: validar kitchen_token + RBAC
    await ws_manager.connect_kitchen(branch_id, ws)
    try:
        while True:
            await ws.receive_text()
    except:
        pass
    finally:
        ws_manager.disconnect_kitchen(branch_id, ws)
7) Endpoints KDS (listado + cambios de estado)
from app.models_kitchen import KitchenTicket, KitchenTicketItem, KitchenStatus

@app.get("/kitchen/tickets")
async def list_tickets(branch_id: int, status: KitchenStatus = KitchenStatus.NEW, db: AsyncSession = Depends(get_db)):
    # branch_id lo sacás vía join session→ table → branch
    # Simplificación: guardá branch_id snapshot en ticket si querés filtrar rápido.
    q = (select(KitchenTicket)
         .where(KitchenTicket.status == status)
         .order_by(KitchenTicket.created_at.asc()))
    tickets = (await db.execute(q)).scalars().all()
    return [{
        "id": t.id,
        "table": t.table_label_snapshot,
        "round": t.round_number,
        "status": t.status.value,
        "created_at": t.created_at,
    } for t in tickets]


@app.post("/kitchen/tickets/{ticket_id}/start")
async def start_ticket(ticket_id: int, branch_id: int, db: AsyncSession = Depends(get_db)):
    t = (await db.execute(select(KitchenTicket).where(KitchenTicket.id == ticket_id))).scalar_one_or_none()
    if not t: raise HTTPException(404, "Ticket not found")
    if t.status != KitchenStatus.NEW: raise HTTPException(409, "Ticket not NEW")
    t.status = KitchenStatus.IN_PROGRESS
    t.started_at = datetime.utcnow()
    await db.commit()
    await ws_manager.broadcast_kitchen(branch_id, {"type":"kitchen_ticket_updated","ticket_id":ticket_id,"status":t.status.value})
    return {"ok": True}


@app.post("/kitchen/tickets/{ticket_id}/ready")
async def ready_ticket(ticket_id: int, branch_id: int, db: AsyncSession = Depends(get_db)):
    t = (await db.execute(select(KitchenTicket).where(KitchenTicket.id == ticket_id))).scalar_one_or_none()
    if not t: raise HTTPException(404, "Ticket not found")
    if t.status not in (KitchenStatus.NEW, KitchenStatus.IN_PROGRESS):
        raise HTTPException(409, "Invalid status")
    t.status = KitchenStatus.READY
    t.ready_at = datetime.utcnow()
    await db.commit()
    await ws_manager.broadcast_kitchen(branch_id, {"type":"kitchen_ticket_updated","ticket_id":ticket_id,"status":t.status.value})
    return {"ok": True}
En producción: el branch_id del evento no lo pases desde el cliente; derivalo desde el ticket → session → table → branch o guardalo “snapshot” en el ticket.

8) Dashboard del cocinero (cómo debería verse)
Columnas típicas en el KDS
Mesa (M-07)

Ronda (2)

Hora (16:23)

Tiempo transcurrido (03:40)

Items (2x Milanesa, 1x Ensalada…)

Notas (sin sal, sin TACC, etc.)

Botones: Start, Ready, Cancel

Filtros
por sucursal

por estación (parrilla, bar, postres)

por estado (NEW / IN_PROGRESS / READY)

9) Puntos de seguridad / consistencia (para que sea “ordenado” de verdad)
El cocinero no ve drafts, solo ve tickets.

Un ticket no se reescribe, solo cambia estado (auditable).

Si se “anula” un pedido: generás ticket CANCELLED (y/o ticket compensatorio).

No aceptes precios del cliente; el server calcula.

Si querés, el siguiente paso te lo dejo ya “cerrado” con:

RBAC (rol kitchen) para acceder al dashboard

Nginx config para /ws/kitchen (Upgrade headers)

y un componente React del dashboard (tabla + columnas + WS + acciones)

Decime si el dashboard del cocinero va a ser:

otra PWA aparte (/kitchen) o

una vista dentro de la app del mozo/admin.

Tú dijiste:
el la pwa anterior dijimos que cada comensal hace un pedido pero debe existir el evento que cierra la ronda, hay que tener un abuena experiencia de usuario, cual es la mas conveniente que el primer comensal que se asigno a la mes ale aparezca el boton? y pueda cerrar la ronda?
ChatGPT Plus
Para buena UX y para que el sistema sea justo + robusto, lo más conveniente no es que “solo el primer comensal” pueda cerrar la ronda.

La mejor práctica en un escenario como el tuyo (QR compartido, gente que llega tarde, se van, se cambia el teléfono) es:

Recomendación
✅ Cerrar ronda por consenso simple (cualquiera puede proponer, pero hay “cooldown” y confirmación)
En la práctica se implementa como:

Cualquier comensal puede tocar “Enviar a cocina”

Pero el sistema muestra un diálogo de confirmación:
“Se enviará a cocina lo pedido en esta ronda. ¿Confirmar?”

Una vez confirmada:

se cierra la ronda

se generan tickets de cocina

se abre una nueva ronda automáticamente

Esto es lo más usable: no depende de “el primero” ni de una figura fija.

Si querés control, hay 3 opciones ordenadas (de mejor a peor)
Opción 1 (mejor UX): “Cerrar ronda” = acción global con bloqueo por 10–20 segundos
Cualquiera presiona “Enviar ronda”

El backend pone round.status = SENDING (estado transitorio) por ejemplo 15s

Si otro intenta cerrar en ese lapso: “Ya se está enviando la ronda”

Al finalizar: SENT y crea tickets

✅ Pros: simple, no necesita roles, evita dobles envíos
❌ Contras: cualquiera puede apretar (se resuelve con confirmación y UI clara)

Opción 2 (control suave): “Solo el ‘host’ de la mesa”
Esto es lo que vos proponés: el primer comensal es “host”.

✅ Pros: control claro
❌ Contras grandes:

si ese comensal se va / se le apaga el celu: quedan trabados

es injusto (no siempre el primero es “responsable”)

genera soporte (“no me aparece el botón”)

Si igual querés host, hacelo bien:

host transferible (cualquiera puede “pedir control” y el mozo/admin lo reasigna)

o “host = el último que escaneó el QR del display” (cambia por sesión)

Opción 3 (mejor para operación real): Cerrar ronda solo el mozo
✅ Pros: cocina recibe orden “limpia” y controlada
❌ Contras: en autoservicio puro empeora UX (dependés del mozo)

Mi propuesta final (la más conveniente para tu caso)
“Enviar pedido” es individual, pero “Cerrar ronda” es global con consenso simple
Cómo se ve en la UI:

Cada comensal tiene su botón: “Enviar mi pedido”
(esto manda su Order a SENT, pero todavía NO cierra ronda)

En la vista “Mesa (resumen)”, aparece un botón global:
“Enviar ronda a cocina”
con texto: “Incluye todos los pedidos enviados en esta ronda”.

📌 ¿Quién ve ese botón?

Todos, pero con protección:

si no hay orders SENT pendientes → deshabilitado

confirmación modal

y backend con idempotencia (no se puede cerrar dos veces)

Implementación técnica recomendada (2 claves)
1) Estado transitorio para evitar dobles cierres
RoundStatus: OPEN → CLOSING → SENT

al apretar:

UPDATE round SET status='CLOSING' WHERE id=:rid AND status='OPEN'

si rows_affected = 0 → alguien ya la está cerrando

2) Idempotencia en el cierre
Generás KitchenTicket con un unique_key = session_id + round_number
y un UNIQUE en DB.

Así aunque por error peguen dos requests, no duplica tickets.

Respuesta directa a tu pregunta
“¿Es mejor que el primer comensal tenga el botón y pueda cerrar la ronda?”

No es lo más conveniente por experiencia y por robustez.

✅ Mejor: cualquiera puede cerrar la ronda, pero con:

confirmación

bloqueo temporal / estado CLOSING

idempotencia en DB

y (opcional) “host transferible” si querés una figura responsable

Si querés, te paso el endpoint real POST /rounds/{id}/close con:

transacción SQL

SELECT ... FOR UPDATE

creación de tickets por round

broadcast WS a cocina + a la mesa

Tú dijiste:
el mozo tambien debe tener un porque el es el unico que puedde liberar ls amesas cuando se retiran los comensales. y tambien para ver el pedido que le llega al cicinero y que recib auna alarma cuando la ronda ya esta cocinada para servir
ChatGPT Plus
Sí, totalmente: el mozo tiene que ser un actor “operativo” con permisos especiales. En tu sistema conviene modelarlo como rol STAFF (waiter) y darle dos capacidades clave:

Cerrar/liberar la mesa (cerrar la sesión) cuando se van los comensales.

Orquestar el servicio: ver lo que está preparando cocina y recibir alertas cuando un ticket/ronda esté READY para servir.

Abajo te lo dejo ordenado como diseño + flujo + endpoints + eventos.

1) Roles y permisos mínimos (RBAC)
Comensal (guest)
crear/editar su Order DRAFT

enviar su pedido (Order → SENT)

ver estado de cuenta y pagos (no confirmar efectivo)

Cocina (kitchen)
ver cola de tickets

pasar ticket: NEW → IN_PROGRESS → READY

Mozo (waiter) — el que pedís
ver mesas/sesiones activas

ver pedidos enviados y estado de cocina

marcar “servido” (opcional) y resolver incidencias

confirmar pagos en efectivo

cerrar sesión / liberar mesa (solo si la cuenta está en 0 o con override autorizado)

2) Eventos que necesitás para que todo “fluya”
Eventos desde “mesa” (comensales)
order_sent (nuevo pedido enviado)

round_closed (si usás cierre de ronda)

payment_confirmed (MP/cash)

Eventos desde “cocina”
kitchen_ticket_new

kitchen_ticket_updated (IN_PROGRESS / READY)

kitchen_ticket_ready (este dispara alarma al mozo)

Eventos para el mozo
waiter_alert_ready (mesa X, ronda Y lista)

session_closed (mesa liberada)

3) Canales WebSocket recomendados (muy simple y escalable)
ws/session/{session_id} → para comensales (estado de su mesa)

ws/kitchen/{branch_id} → para cocina (cola por sucursal)

ws/waiter/{branch_id} → para mozos (alertas operativas por sucursal)

Con esto:

cocina no se entera de pagos

comensales no ven cola de cocina global

mozo ve todo lo operativo

4) Modelo de datos: qué agregar
Ya tenías KitchenTicket y KitchenTicketItem. Sumá:

A) served_at / served_by_waiter_id (opcional)
En KitchenTicket:

served_at (timestamp)

served_by (staff id)

B) Staff y asignación (mínimo)
StaffUser (id, branch_id, role: WAITER/KITCHEN/ADMIN, name, pin/password)

(opcional) WaiterAssignment (session_id, waiter_id) para saber qué mozo atiende qué mesa
Si no querés asignación: todos los mozos del branch reciben alertas.

5) Flujo operativo completo (lo que querés)
1) Comensales envían pedidos
Generan órdenes y/o cierran ronda → se crean KitchenTicket(s).

2) Cocina trabaja y marca “READY”
Cocina hace POST /kitchen/tickets/{id}/ready

Al pasar a READY el backend:

emite WS a waiter/{branch_id}:

mesa, ronda, items resumidos

opcional: emite WS a session/{session_id} para que los comensales vean “Listo para servir”.

3) El mozo recibe alarma y sirve
El dashboard del mozo suena/vibra (PWA)

Mozo confirma “Servido”:

POST /waiter/tickets/{id}/served (opcional, pero recomendable)

4) Cuando se van: mozo libera mesa
POST /waiter/sessions/{session_id}/close

Backend valida:

que balance_due == 0 (o requiere override admin)

y cierra TableSession → mesa queda libre para un nuevo QR/sesión

6) Endpoints concretos que tenés que sumar
Mozo
GET /waiter/boards/{branch_id}/sessions
Lista mesas activas + estado (OPEN/PAYING), total, balance, última ronda, tickets READY pendientes.

GET /waiter/sessions/{session_id}
Detalle: órdenes, cargos, pagos, tickets cocina.

POST /waiter/tickets/{ticket_id}/served
Marca servido (opcional).

POST /waiter/sessions/{session_id}/close
Libera mesa (solo waiter/admin).

Cocina (ya lo tenés)
GET /kitchen/tickets?branch_id=&status=NEW

POST /kitchen/tickets/{id}/start

POST /kitchen/tickets/{id}/ready

7) “Alarma” en PWA del mozo: cómo hacerlo bien
Tenés 3 niveles (de mejor a más simple):

Nivel 1 (ideal): Push Notifications (Web Push)
Requiere service worker + suscripciones (VAPID)

Cuando ticket pasa a READY → disparás push al mozo

Funciona incluso con pantalla apagada (según móvil)

Nivel 2 (muy bueno y rápido): WebSocket + sonido/vibración
Si el mozo tiene el dashboard abierto:

al recibir waiter_alert_ready:

reproducís sonido

vibración (si aplica)

badge y “toast”

Nivel 3 (fallback): polling cada 5–10s
Si el WS se corta, reintenta

Si no hay soporte WS, usás GET /waiter/boards/... en intervalos

Recomendación práctica: WS + fallback polling al inicio. Push lo sumás después.

8) Regla clave de UX
El comensal puede “enviar su pedido”, pero no puede liberar la mesa.

Cocina puede marcar READY, pero no puede cerrar sesión.

El mozo es el único que:

confirma efectivo

cierra sesión (libera mesa)

opera “servido” si querés trazabilidad del servicio

9) Nginx (solo para que no se rompa WS)
Si tenés Nginx delante, asegurate de rutear:

/ws/waiter y /ws/kitchen con headers Upgrade y Connection: upgrade.

Si querés, en el próximo mensaje te paso código real (igual que antes) para:

ws/waiter/{branch_id} + broadcast_kitchen_ready(...)

endpoint POST /waiter/sessions/{id}/close validando balance_due==0

endpoint POST /waiter/tickets/{id}/served

query GET /waiter/boards/{branch_id}/sessions que arma el dashboard con joins/aggregations eficientes.

